
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>JS-前端MVC和传统MVC的区别 | Steam</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Steam">
    
    <meta name="description" content="关于MVC，实际上分为前端 MVC 和传统的 MVC，这个概念是由 JC 告诉我的，但是我一直没有能够理解。后来在网上找了一些资料，再加上项目上的一些实践，慢慢的对这个概念有些深入的理解了，现在的感觉就是似乎这个前端 MVC 其实就是把后端的一些操作放在了前端，本质就是为了让用户和机器的几乎能够更加">
    
    
    
    
    <link rel="alternative" href="/Tinnypp/atom.xml## RSS address." title="Steam" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/Tinny.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/Tinny.jpg">
    

  
    <link href="/css/font-awesome.min.css" rel="stylesheet">
    
  
  <link href="http://cdn.bootcss.com/highlight.js/8.2/styles/railscasts.min.css" rel="stylesheet">
  <script src="http://cdn.bootcss.com/highlight.js/8.2/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

    <link rel="stylesheet" href="/css/style.css">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?d182ed77fc48758bf45a33835ee35745";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','.............Add your swiftype userID...............');
</script>
</head>

  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Steam">Steam</a></h1>
				<h2 class="blog-motto">DREAM makes you different</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
                    <ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
						<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="st-search-inpu" maxlength="20" placeholder="Search" />
						</form>
					
					</li>
                <!--<li><div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div></li>-->

				</ul>
			</nav>	
</div>
    </header>
    <div id="container" class="clearfix">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/14/JS-前端MVC和传统MVC的区别/" title="JS-前端MVC和传统MVC的区别" itemprop="url">JS-前端MVC和传统MVC的区别</a>
  </h1>
  <p class="article-time">
    <time datetime="2016-08-14T07:15:26.000Z" itemprop="datePublished">2016-08-14</time>
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title"></strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Quora-What-are-the-differences-between-MVC-on-the-frontend-and-MVC-on-the-backend"><span class="toc-number">1.</span> <span class="toc-text">Quora - What are the differences between MVC on the frontend and MVC on the backend?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quora-Why-do-we-need-two-mvc-for-a-web-app-both-for-frontend-and-backend"><span class="toc-number">2.</span> <span class="toc-text">Quora - Why do we need two mvc for a web app both for frontend and backend?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#知乎-前端-MVC-和服务器端有哪些差别？"><span class="toc-number">3.</span> <span class="toc-text">知乎 - 前端 MVC 和服务器端有哪些差别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#知乎-怎么更好的理解虚拟DOM"><span class="toc-number">4.</span> <span class="toc-text">知乎 - 怎么更好的理解虚拟DOM?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">5.</span> <span class="toc-text">其他</span></a></li></ol>
		</div>
		
		<p>关于MVC，实际上分为前端 MVC 和传统的 MVC，这个概念是由 JC 告诉我的，但是我一直没有能够理解。后来在网上找了一些资料，再加上项目上的一些实践，慢慢的对这个概念有些深入的理解了，现在的感觉就是似乎这个前端 MVC 其实就是把后端的一些操作放在了前端，本质就是为了让用户和机器的几乎能够更加快捷，不知道自己的理解对不对。下面有两篇文章我觉得写得都不错，尤其推荐Quora上的这个问题的回答，解释的非常清楚。</p>
<h3 id="Quora-What-are-the-differences-between-MVC-on-the-frontend-and-MVC-on-the-backend"><a href="#Quora-What-are-the-differences-between-MVC-on-the-frontend-and-MVC-on-the-backend" class="headerlink" title="Quora - What are the differences between MVC on the frontend and MVC on the backend?"></a>Quora - What are the differences between MVC on the frontend and MVC on the backend?</h3><p><a href="https://www.quora.com/What-are-the-differences-between-MVC-on-the-frontend-and-MVC-on-the-backend" target="_blank" rel="external">原文链接</a></p>
<p>Fernando Zamora的回答：</p>
<blockquote>
<p>MVC stands for model view controller.</p>
<p>The model is basically your business logic. The model is all your entities, your value objects, anything related to the business logic. It also makes use of data objects (repositories, etc.) to perform the CRUD operation.</p>
<p>The view is the user interface. It is usually the presentation. Usually the view performs minimal programming logic mostly related to organizing the presentation of the data.</p>
<p>The controller is the mediator between the user’s request and the model.</p>
<p>With that said MVC on the back end means that whenever a http request comes in the Controller handles the operation by handing over the received data and communicating with the model. After it coordinates the operation typically it responds to the client by sending down a view. A view usually consists of some script that combines the view model with HTML. The view engine works the magic to generate HTML from this script. The script can be in the form of JSP, Razor scripts, PHP etc. The controller sends back that HTML, well not directly since there is usually an entire framework that handles the response details but to you as a user of that MVC framework it appears the controller sends it. All these operations take place on the back end. This is MVC on the back end.</p>
<p>With MVC on the front end there is usually a framework, typically written in JavaScript(or maybe always a JavaScript framework). You leverage that framework to perform the MVC logic on the client. That framework is responsible for handling templates and combining them with logic to render dynamic web pages. The controller still handles a lot of the work going on but it’s going in the client. All the templates usually get downloaded only once and they are manipulated with logic as needed. To fetch data you can utilize some of the frameworks code to perform the calls to the back end. The framework likely uses AJAX (with Json usually) fetch the data. The requests receive the data and the controller maps that data to entries on HTML templates which render the dynamic page.</p>
<p>The main difference between MVC on the client and MVC on the back end is that with MVC on the front end there is minimal code running on the server. The server is mainly used for handling web API requests which respond with JSON data. The back end is quite light weight. With MVC on the back end you are receiving the full HTML page every time.</p>
<p>Another notable difference is that MVC on the front end will seem more responsive since you are relying on JavaScript for changing your views around. Buttons show and hide in an instant. Views show and hide as well. Controls can double bind easily meaning that as you enter data in one control it updates another control in real time.</p>
<p>MVC on the front end may increase the handling capabilities of your server because it has a lighter load. On the flip side, if you have large JavaScript files it can actually create download and bandwidth issues for your users.</p>
<p>For MVC on the back end you have the choice of many different languages; Java, C#, Ruby, JavaScript(Node), PHP, etc. Each one of these with their own MVC framework.</p>
<p>With MVC on the front end you have a choice of different frameworks or libraries which all rely on JavaScript.</p>
<p>MVC on the client in may cases is also referred to as single page application (SPA) since all you are doing is manipulate UI templates around the single page.</p>
</blockquote>
<hr>
<p>Alex Rogachevsk 的回答：</p>
<blockquote>
<p>Technically MVC entirely resides in the physical “back-end” i.e. the Web server, rather than the browser. The page is completely rendered there and sent to the browser as an HTTP reply. Anything it produces e.g. JavaScript lives its own life.</p>
<p>Some may refer to the “V” (view) as the “front end” since it (e.g. a JSP page or Groovy template) represents your templated HTML.</p>
<p>Honestly I don’t know how AJAX fits into MVC other than those “cargo” calls are commonly fulfilled by Spring MVC Controllers - that definitely lack the View. They return the raw Model directly e.g. in JSON form.</p>
<p>If you want to impress someone at the interview with your deep understanding of the MVC pattern, you can also google MVC1 vs. MVC2. No one has used MVC1 since 2000.</p>
<p>There is also a lesser known, but just as powerful MVP (Model, View, Presenter) pattern originated in 100% client-side frameworks like GWT and later influenced also 100% front-end Android API.</p>
</blockquote>
<hr>
<p>Miguel Paraz 的回答：</p>
<blockquote>
<p>“MVC on the back-end”, with frameworks such as Spring MVC, means that the dynamic code and data that make up the MVC all reside on the server, but it is not purely back-end because the view is rendered on the browser. In its purest form, the MVC is implemented by full page refreshes as there is no dynamic code to do the redrawing on the browser.</p>
<p>“MVC on the front-end” with JavaScript frameworks move the model, view and controller to dynamic code and data running in the browser. This makes it closer to the original idea of MVC designed for desktop GUI applications. To make it more confusing, these frameworks can talk to the back-end using RESTful endpoints implemented with the Spring MVC framework - but using Spring this way is not making use of the MVC pattern.</p>
</blockquote>
<h3 id="Quora-Why-do-we-need-two-mvc-for-a-web-app-both-for-frontend-and-backend"><a href="#Quora-Why-do-we-need-two-mvc-for-a-web-app-both-for-frontend-and-backend" class="headerlink" title="Quora - Why do we need two mvc for a web app both for frontend and backend?"></a>Quora - Why do we need two mvc for a web app both for frontend and backend?</h3><p><a href="https://www.quora.com/Why-do-we-need-two-mvc-for-a-web-app-both-for-frontend-and-backend" target="_blank" rel="external">原文链接</a></p>
<p>这个回答也讲解的非常好！</p>
<p>Cheng Lou 的回答：</p>
<p>I’ll assume for the sake of the question that the front-end is really a MVC, although currently most popular front-end paradigms are MV* (as in, something).</p>
<p>That’s because these two MVCs don’t fill the same role, and the fact both ends are using the same paradigm is simply due to the effectiveness of it.</p>
<p>The Model:</p>
<p>Server-side: connection to database to retrieve/store info: get a list of student names.<br>Client-side: structuring AJAX data: get a JSON representation of student names, store it for easy manipulation in an object with convenient methods such as delete (which, say, triggers a DELETE request to the server).</p>
<p>The Controller:</p>
<p>Server-side: the coordinator between data and views: the client requested a page which needs the list of student names; get it from the model and insert it into a determined view, then send it.<br>Client-side: same here. In some cases it also takes care of routing, i.e. changing the URL without refreshing the page (simply request another JSON to fill the page).</p>
<p>The View:</p>
<p>Server-side: most probably a template html page, that the controller takes as a big string and insert data where needed: loop through the student names and generate a line of ‘<li>studentName[i]</li>‘ each time. At the end, you get a valid html string.<br>Client-side: manipulates the UI, add interactivity: make students whose family name start with ‘A’ flashy red, and when hovered, display more info.</p>
<p>The big reason why there are two MVCs is because the front end cannot communicate directly with a server database, and the back end cannot dynamically update UI and respond to interactivity. The two MVCs do different jobs.</p>
<p>That being said, a while ago, and if you really stretch the definition of ‘web app’, serving plain, JavaScript-less static pages was viable. In that case, There’s no need for a client-side paradigm. You click on a page, it triggers a request to server, which uses MVC to send you another page, rinse and repeat. Some might recall those click-refresh-click games made in PHP back then.</p>
<p>But the modern web apps need interactivity; you can’t possibly create a good experience by refreshing the screen each time you make an action. Can you imagine Facebook refreshing each time you send a message to your buddy?</p>
<p>Side notes:</p>
<ol>
<li><p>Meteor tries to change this, at least on the apparance, by “merging” client-side and server-side through Node.js (JavaScript on the server). This can alleviate some pain.</p>
</li>
<li><p>Theoretically, if there exists a client-side view system so powerful that you can just take the data and feed it to a UI without worrying too much about organizing data and coordinate it with controllers, then you could also eliminate a big chunk of the need of a front end MVC.</p>
</li>
</ol>
<h3 id="知乎-前端-MVC-和服务器端有哪些差别？"><a href="#知乎-前端-MVC-和服务器端有哪些差别？" class="headerlink" title="知乎 - 前端 MVC 和服务器端有哪些差别？"></a>知乎 - 前端 MVC 和服务器端有哪些差别？</h3><p><a href="https://www.zhihu.com/question/20440717" target="_blank" rel="external">原文链接</a></p>
<p>尤雨溪的回答</p>
<p>作者：尤雨溪<br>链接：<a href="https://www.zhihu.com/question/20440717/answer/15684806" target="_blank" rel="external">https://www.zhihu.com/question/20440717/answer/15684806</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
<p>服务器端的MVC，每次用户干了什么，流程大致是这样的：</p>
<p>客户端发送请求 -&gt; 服务器触发Controller -&gt; 服务器进行Model各种操作 -&gt; 服务器根据Model数据渲染View -&gt; 服务器回复请求，包含了整个View的html -&gt; 客户端重新渲染整个页面，所有的css都又计算了一遍，所有的js都重新执行了一遍，所有的资源都重新请求了一遍（虽然可能已经cache了）</p>
<p>前端MVC的话则是这样的（前端其实大部分是MV+X，不一定有Controller):</p>
<p>客户端根据用户的行为修改客户端Model -&gt; 客户端更新和该Model相关的View -&gt; 客户端Model发送sync请求到服务器，只包含改变了哪些数据 -&gt; 服务器审核数据改动是否合法，只需回复是否修改成功 -&gt; 客户端收到成功，什么都不用做；不成功，则把刚才改的View改回来，然后通知用户。（当然，也可以在客户端的Model里面也加入审核机制，这样对不合法数据的反应更快，但还是得保留服务器端的审核）</p>
<p>比较一下可以看到，前端MVC需要向服务器端传递和接收的数据量都少很多，而前端要做的等待和渲染工作也少了很多。换言之，会提供更快的交互反馈，也意味着更好的用户体验。同时，服务器端的负载也略有降低，因为基本上只需要在数据库上提供一个RESTful API即可。</p>
<h3 id="知乎-怎么更好的理解虚拟DOM"><a href="#知乎-怎么更好的理解虚拟DOM" class="headerlink" title="知乎 - 怎么更好的理解虚拟DOM?"></a>知乎 - 怎么更好的理解虚拟DOM?</h3><p>在学习 MVC 的过程中会看到其他 MV* 模式的框架，比如 MVP, MVVM 这一类的，而 React 和 Vue 都是 MVVM 框架，其中 VM 表示的是 Virtual Dom。那么应该如何更好的理解虚拟 DOM 呢？我查了很多内容，其中知乎上的这篇文章排名第一的<a href="https://www.zhihu.com/question/29504639" target="_blank" rel="external">回答</a>写的非常好，值得参考。知乎这个回答是搬了回答者 github 上的内容，这里把原 github 地址放在这里供大家参考。</p>
<p><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="external">https://github.com/livoras/blog/issues/13</a></p>
<p>看了这个回答之后，你会发现数据结构和算法依然是非常重要的内容，因为这些框架和库的很多内容其实就是利用算法和数据结构的知识写的。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>通过 google 或者 bing 可以搜索到很多关于这方面的问答、博客、文章。下面这些内容，讲的也非常好，但是时间关系，先将内容列出来，然后再慢慢阅读、消化、总结。</p>
<ul>
<li><a href="http://joomlatuts.net/joomla-2-5/87-how-backend-model-view-controller-mvc-works-in-joomla/98-difference-between-frontend-and-backend-mvc" target="_blank" rel="external">http://joomlatuts.net/joomla-2-5/87-how-backend-model-view-controller-mvc-works-in-joomla/98-difference-between-frontend-and-backend-mvc</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-front-end-and-back-end-development" target="_blank" rel="external">https://www.quora.com/What-is-the-difference-between-front-end-and-back-end-development</a></li>
<li><a href="https://www.quora.com/What-are-the-main-differences-between-MVC-MVP-and-MVVM-design-patterns-for-the-JavaScript-developer" target="_blank" rel="external">https://www.quora.com/What-are-the-main-differences-between-MVC-MVP-and-MVVM-design-patterns-for-the-JavaScript-developer</a></li>
<li><a href="https://www.quora.com/Whats-the-difference-between-MVC-vs-MVVM" target="_blank" rel="external">https://www.quora.com/Whats-the-difference-between-MVC-vs-MVVM</a></li>
</ul>
<p>– 更新于 2016.11.14</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/JS/">JS</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2016/08/14/JS-前端MVC和传统MVC的区别/" data-title="JS-前端MVC和传统MVC的区别 | Steam" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/24/others-关于-fallback-colors/" title="others-关于 fallback colors">
  <strong>新一篇:</strong><br/>
  <span>
  others-关于 fallback colors</span>
</a>
</div>


<div class="next">
<a href="/2016/08/07/Git-gitignore-文件失效可能的原因/"  title="Git-.gitignore 文件失效可能的原因">
 <strong>舊一篇:</strong><br/> 
 <span>Git-.gitignore 文件失效可能的原因
</span>
</a>
</div>

</nav>

	
<section class="comment">
	
	<div class="ds-thread" data-title="JS-前端MVC和传统MVC的区别" data-thread-key="JS-前端MVC和传统MVC的区别" data-author-key="Steam" data-url="http://yoursite.com/post/JS-前端MVC和传统MVC的区别"></div>
	
</section>


</div>  
    </div>
    <footer><div id="footer" >
	<div class="copyright">
		<span>Powered by <a href="https://github.com/hexojs/hexo">Hexo</a> and theme by 
		<a href="https://github.com/levonlin/Tinnypp">Tinnypp</a>.</span>
		
			<span>© Steam</span>
		
	<div>
</div></footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  //back to top
  function backToTop(){
    var buttonHTML = $("<a href=\"#top\" id=\"back-top\">" + "<span>Back to Top</span></a>");
    buttonHTML.appendTo($("body"));
    var buttonToTop = $("#back-top");
    // hide #back-top first
    buttonToTop.hide();

    // fade in #back-top
    $(function() {
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                buttonToTop.fadeIn();
            } else {
                buttonToTop.fadeOut();
            }
        });
        // scroll body to 0px on click
        buttonToTop.click(function() {
            $('body,html').animate({
                scrollTop: 0
            }, 800);
            return false;
        });
    });
  }
  backToTop();

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      ta = $('#toc.toc-aside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
        
    }
  });

  var show = true;
  c.click(function(){
    if(show == true){
        a.addClass('fadeOut').css('display', 'none');
        ta.css('display', 'block').addClass('fadeIn');
        m.addClass('moveMain');  
    }else{
        a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');     
        ta.css('display', 'none'); 
        m.removeClass('moveMain');
        $('#toc.toc-aside').css('display', 'none');
    }
    show = !show;
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{

    $(window).scroll(function(){
      ta.css("top",Math.max(140,240-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"tinnypp"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';    //change to ds.src = '/js/embed.js'; to add useragent for duoshuo
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>

<script type="text/javascript">
  function footerPosition() {
    var contentHeight = document.documentElement.scrollHeight,
        winHeight = window.innerHeight;
    if(contentHeight <= winHeight) {
      $('footer').addClass('fixed-bottom');
    } else {
      $('footer').removeClass('fixed-bottom');
    }
  }
  footerPosition();
  $(window).resize(footerPosition);
</script>


  </body>
</html>
